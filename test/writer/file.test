UTest({
	$before: remove,
	$after: remove,
	'write': function(done){
		var config = new Config({
			path: path_JSON,
			writable: true
		});
		
		config
			.$write({
				foo: 'baz',
				arr: [1]
			})
			.fail(assert.avoid())
			.done(function(){
				var cfg = io.File.read(path_JSON);
				
				eq_(cfg.foo, 'baz');
				deepEq_(cfg.arr, [1]);
				done(config);
			});
		
	},
	'write extend': function(done, config){
		
		config
			.$write({ arr: [2] })
			.done(function(){
				var cfg = io.File.read(path_JSON);
			
				eq_(cfg.foo, 'baz');
				deepEq_(cfg.arr, [1, 2]);
				done();
			})
	},
	'write after read': function(){
		return Config.fetch({
				path: path_JSON,
				writable: true
			})
			.pipe(config => {
				deepEq_(config.toJSON(), {
					foo: 'baz',
					arr: [1, 2]
				});
				
				return config
					.$write({ qux: 'quux', arr: [3] })
					.pipe(() => {
						var cfg = io.File.read(path_JSON);
						deepEq_(cfg, {
							qux: 'quux',
							foo: 'baz',
							arr: [1, 2, 3]
						});
					})
			})
	},
	'should write yaml': function(){
		var config = new Config({
			path: path_YML,
			writable: true
		});
		
		return config
			.$write({
				foo: 'baz'
			})
			.done(function(){
				var txt = io.File.read(path_YML, { skipHooks: true });
				
				has_(txt, 'foo: baz');
			});
	},
	'should write json to any generic extension': function(){
		var config = new Config({
			path: path_TXT,
			writable: true
		});
		return config
			.$write({
				foo: 'baz'
			})
			.done(function(){
				var txt = io.File.read(path_TXT, { skipHooks: true });
				
				has_(txt, '{"foo":"baz"}');
			});
	}
})

var path_JSON = 'test/bin/write.json',
	path_YML = 'test/bin/write.yml',
	path_TXT = 'test/bin/write.txt'

function remove() {
	io
		.Directory
		.remove('test/bin/');

}